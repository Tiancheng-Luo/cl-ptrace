
# Notes while reading http://tldp.org/LDP/LGNET/81/sandeep.html
#                     http://www.linuxjournal.com/article/6210
#                     http://www.hep.wisc.edu/~pinghc/Process_Memory.htm
#                     cffi manual

* =ptrace()= protoype:
  #+BEGIN_SRC c
    #include <sys/ptrace.h>
    long  int ptrace(enum __ptrace_request request, pid_t pid,
                     void * addr, void * data)
  #+END_SRC

  *request* decides what to be done
  *Pid* - Pid of the _traced_ process
  *Addr* offset in the _user space_
  *data* will be written to, if instructed to do so (depending on request)

* =fork()= =PTRACE_TRACEME=
  This is what we're using: A parent fork()'s and the resulting child calls
  =ptrace(PTRACE_TRACEME, ..)= to initiate being traced by the parent.

* How does =ptrace()= work
  whenever ptrace is called it _first locks the kernel_ (TODO: why), just before
  returning it unlocks the kernel. Depending on the request different things happen
  in between the locks. What follows is an overview of the requests behaviour

** =PTRACE_TRACEME=
   Any signals (except SIGKILL) either delived from outside or from *exec* calls made by
   the process, causes it to stop and lets the parent decide how to proceed.
   This request only sets a flag that grants permission to trace the process.
   *Important insight*: _All the parameters other than *request* are ignored_!

** =PTRACE_ATTACH=
   This is pretty handy, you can make the current process the tracer of the target
   process, "become the parent of that process by attach yourself to it". But =getpid()=
   will return the child's real parent!
   - Note: the *init* process is a big deal - nobody is allowed to trace or control it!  A
     process is also not allowed to trace itself.
   What actually happens:
   1. In the background all the cases are handled (1) is it the init (2) itself aka
      current process (3) already traced process, before permission to attach is granted.
   2. "the child is removed from the task queue and its parent process field is changed
      (...). It is put to the queue again in such a position that *init* comes next to it"
   3. (!)Interesting: _finally a =SIGSTOP= signal is delivered to it._ This could be useful
      to attach to the process in the moment when inspecting the process memory is of
      interest!

** =PTRACE_DETACH=
   The inverse of =Ptrace_Attach=: (1) reset the Ptrace flag, (2) move child to original
   position of the task queue (note task=process in kernel lingo) and finally (3) the pid
   of the real parent is written in the parent field. "The single-step bit which might
   have been set is reset".
   *addr* is ignored
   *data* arg the parent can send an exit code for the child
   

   
** =PTRACE_CONT=
   to continue child execution

** =PTRACE_SYSCALL=
   will also continue execution of the child, but will stop every syscall invokation the
   child issues. This can be used to implement "strace".

** =PTRACE_SINGLESTEP=
   like =PTRACE_SYSCALL= except we stop here on every instruction!
   
** =PTRACE_GETREGS=
   fetches registers of the process such as: general purpose, floating point.
   *data* will store these, furthermore it expects a =struct user_regs_struct= variable!

** =PTRACE_PEEKTEXT PTRACE_PEEKDATA=
   Read a word from the process' memory.
   apparently they're identical on linux because "Linux does not have separate text and
   data address spaces". 
   *addr* is the byte offset from which to read the word[fn:3]
   *data* is ignored

** =PTRACE_PEEKUSER=
   Read a word from the tracee's USER area (register + open files, etc. see below)
   *addr* is the byte offset from which to read the word
   *data* is ignored

*** PTRACE_PEEK*
   - if PTRACE_PEEK* calls are unsuccessful they return zero!
   - "On error, all request return -1, and _errno_ is set appropriately (...)"

   
** =PTRACE_GETREGS=
   Reads all the registers of the tracee's USER area and puts it in the given struct of
   type =user_regs_struct=
   *data* expects a pointer to =user_regs_struct=, so pass by reference, and fills it with
          the registers of the tracee
   *addr* is ignored

** =PTRACE_POKETEXT PTRACE_POKEDATA PTRACE_POKEUSER=
   The inverse of the above: write the given word at the offset (in bytes) specified in
   the data or user area of the tracee.
   *data* word to write to tracee
   *addr* byte offset where to write to
   
   

* A process issues a system calls
  When a process wants to invoke a system call, it puts the arguments to system calls in
  registers =rdi rsi rdx rcx r8 r9= -in that order- and calls the soft interrupt[fn:1] 0x80 (TODO:
  0x80 on i386). This code is put in the =rax=[fn:2] register on x86_64 architecture machines.
* system call numbers
  Can be found in /usr/include/asm-generic/unistd.h !




* The Process

** contains
   - program counter
   - all the CPU's registers
   - process stack (containing temporary data) such as:
     - routine parameters
     - return addresses
     - saved variables

  
** User Area + Contents
   is a reagion of the process' memory that contains information about:
   - open files
   - current directory
   - signal action
   - "accounting information"

   
  

* Footnotes

[fn:1] a soft interrupt is to be contrasted by a hardware interrupt. Both are like a
function that takes highest priority and interrupts every other non-interrupt execution of
instruction. A hardware interrupt is issued by hardware, a soft interrupt is issued by the
program code.
Examples - hardware interrupt:
1. telling the CPU when I/O components are available - instead of a spin lock solution
2. watchdog circuits - tell the CPU if some hardware component is not working properly
   these are interrupts are highly critical. Interupts have a priority hierarchy scheme so
   that these kind of interrupts can get handled before others.
Examples - software interrupt:
1. system calls!
2. Programming language Exception system is handled through software interrupts! Such as
   division-by-zero

[fn:2] on i386 this is the =eax= register - a 32bit register

[fn:3] the size of a word is architecture and OS dependent: on x86_64 Linux it is 64bit

  


* TODO Inspect instructions of the memory
  - is the instruction pointer used to read from the process memory part, using PTRACE_PEEKDATA?
  - If so, inspect if the commands match the executable e.g. ./bin/spam  !

* TODO Registers reserved for global variables
  Some CPUs implement a register window scheme to deal with local variables of procedure
  calls efficiently. Along with this scheme there are some Registers that are reserved for
  global variable - accessed by all procedures as they call deeper and deeper. On the
  SPARC-Architecture those are R0 to R7.
  - Try to figure out if x86-64 also has those

* gcc

** TODO =gcc -g=
   "with this option the compiler and linker will generate and retain symbol information
   in the executable itself"
   For example loading the executable with =gdb= allows to associate the sourcecode files
   with the produces assembly. =(gdb) info line 12= for example, will show at what address
   in the process memory those are mapped to.
   Though since we can read out the instruction pointer we can pass that address to gdb
   and get the assembly pointed at !
   For exmaple:
   =(gdb) disassembly 0x400500= 
   
* TODO Disable Adress Space Layout Randomzation (ASLR)
  On Linux:
  =echo 0 > /proc/sys/kernel/randomize_va_space=

  This might be needed, or come in handy


* /proc/pid/maps memory layout
  "A file containing the currently mapped memory regions and their access permissions"
  from =man proc=.  shows the virtuel address space of a process and its protection
  (read,write,executable).  See the function in util.c called =find_readable_memory= to
  find the regions corresponding with 'r' as in 'r'eadable For example the first row of
  /proc/pid/maps:

| start-end of virtual | permission            |   offset |    dev |   inode | pathname     |
| address              | last one is p=private |          |        |         |              |
|                      | or  s=shared          |          |        |         |              |
| 00400000-00401000    | r-xp                  | 00000000 | 103:03 | 8529909 | /path/to/exe |
|                      |                       |          |        |         |              |

permission, can be changed using the =mprotect= syscall
When a process violates its memory access then a SIGSEGV (segmentaiton fault) is issued by
the kernel.
TODO: not sure if permission hinders PTRACE_POKE* in any sense, as it didn't hinder it on
'w' lacking regions.. might be because I was using a sudo (root privilege sudo command)
tracer process to do so..?

dev, pathname and inode,
help us find the file on the disc that this process was fed data from (I think this is the
executable)

offset,
is the offset into the file we wrote into memory and mapped with virtual addresses

pathname,
this one is useful for example "[stack]" might be the area containing the dynamic object,
so if you want to =ptrace()= a particular runtime object, this is where we
might find them

** pathname and hexaddress in memory:
you can peek_data the instructions and the search them in the executable, they're usually
in order. But very important when you search the address you have to consider if you're
machine uses big- or little-endian. I think most machines use little-endian. Because now
a peekadress might return: 200b5b058901c083
but the address is laid out in memory
PEEKDATA:  200b 5b05 8901 c083 
in memory: 83c0 0189 055b 0b20

in the hexeditor a word is in fact a halfword it seems, just look at the last entry in the
PEEKDATA row is c083 and in memory it is the leading chuck, we start with the least
significant portion of a datum (little endian). Because we have broken down the datum in
in 4x4hex value. We get 4 halfword because 0xffff can represent up to 16⁴ or 2¹⁶ aka 16
bit (halfword).

The definition of a "word" is not very rigid, but in the literature I use a word is 32bit,
double word 64bit and consequently a halfword is 16bit. Alas in ptrace()'s man page the
"word" is used and annoted as being architecture dependent.





* disassembly hacking
  =(gdb) disas /r main= Shows not only the mnemonics but also the associated process data!!
  returns the disassembly of the main function. The striking oberservation is the way it
  is formated regarding the spacing of addresses. It is important to note that different
  instruction make up a smaller or bigger instruction size!! (You can tell by the <+xyz>
  column and the process data after

  Example from (dspm)
   0x00000000004004ed <+0>:	55	push   %rbp
   0x00000000004004ee <+1>:	48 89 e5	mov    %rsp,%rbp
   0x00000000004004f1 <+4>:	89 7d fc	mov    %edi,-0x4(%rbp)
   0x00000000004004f4 <+7>:	48 89 75 f0	mov    %rsi,-0x10(%rbp)
   0x00000000004004f8 <+11>:	eb 0f	jmp    0x400509 <main+28>
   0x00000000004004fa <+13>:	8b 05 64 0b 20 00	mov    0x200b64(%rip),%eax        # 0x601064 <x>
   0x0000000000400500 <+19>:	83 e8 01	sub    $0x1,%eax
   0x0000000000400503 <+22>:	89 05 5b 0b 20 00	mov    %eax,0x200b5b(%rip)        # 0x601064 <x>
   0x0000000000400509 <+28>:	8b 05 4d 0b 20 00	mov    0x200b4d(%rip),%eax        # 0x60105c <flagg>
   0x000000000040050f <+34>:	3d cd ab 00 00	cmp    $0xabcd,%eax
   0x0000000000400514 <+39>:	74 e4	je     0x4004fa <main+13>
   0x0000000000400516 <+41>:	8b 05 48 0b 20 00	mov    0x200b48(%rip),%eax        # 0x601064 <x>
   0x000000000040051c <+47>:	5d	pop    %rbp
   0x000000000040051d <+48>:	c3	retq   

   The addresses are thus alligned variably! The PUSH operation only needs a single byte!

   As you might notice with the first 3 MOV instruction don't seem to have the same
   opcode. Well first of all there ARE differnt opcode for MOV instructions (see
   "Instruction Set Reference"), but in this case the "89" is the opcode for MOV and in
   the 1st and 3rd line the leading 48 is in fact a _"rex prefix"_ for 64 bit operands and
   registers (%rbp and %rsp are GPRs), that means the the MOV in the 2nd line is a 32bit
   MOV!



   _The rex prefix is a prefix for the opcode byte_ and indicates that 64 bit operands
   or GPRs or FPRs registers will be used.


* Instruction Set Reference
  This is quite helpful
  http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf

* CFFI
  "Bindings [to C] are written in Lisp. They can be created at-will by Lisp programs. Lisp
  programmers can write new bindings and add them to the image (...)
  The only foreign library to load is the one being wrapped- the one with pure C interface; no
  C or other no-Lisp compilation is required."

  Because CFFI can only deal with .so files, a summary follows:

** C - .a and .so files
  shortly put .a are static linked libraries and .so dynamic linked libraries

  .a statically linked:
  This means when a program is linked against it, and the library changed, the program
  needs to be compiled again for it to use the new library. Because the _linking only_
  _takes place once, statically, during compilation_
  If the .a static library changes the program needs to be compiled again, against it for
  the changes to be available to the program

  .so dynamically linked:
  only .so libraries can by dynamically linked when compiling a program. That means
  that once the compilation is complete and the .so library changes in the future,
  the changes will be immediately available to the program because the linking
  is dynamically taking place _at runtime of the application_

** .a .so how does it matter to CFFI?
   Because only shared object files "*.so" can by dynamically loaded into the
   Lisp image for binding creation

** creating .so libraries
   Only differs from regular compilation in the command line switches
   
   =gcc -shared -fPIC -g test.c -o bin/libtest.so=
   
   where =-shared -fPIC= suffices

   I.e. a shared libraries (and also .a files) can be created from any source files

** Creating C bindings from any .so file!!
   All we need is an .so file, and here is how it works:

   1. First we _describe how to load a shared library_ into the Lisp image with
      =define-foreign-library=
      
#+BEGIN_SRC common-lisp
  (define-foreign-library libc-definition-name
    ;; where to fetch the .so files on :unix systems:
    (:unix (:or ;"libc-2.19"
	    "libc.so"
	    "/lib/x86_64-linux-gnu/libc-2.19"))
      ;; default search location - if all fails
      (t (:default "/lib/x86_64-linux-gnu/libc-2.19"
	     "/usr/lib/libc.so")))

#+END_SRC
   2. Then we _actually load the described library_ into the Lisp image

#+BEGIN_SRC common-lisp
  (use-foreign-library libc-definition-name)
#+END_SRC      

   3. And now we can _create the bindings to the functions we care about_

#+BEGIN_SRC common-lisp
  (defcfun ("abs" absoluto) :int (flags :int))
  ;; "abs" is the name of the clib function where `absoluto' refers to the name we can
  ;; invoke it with in the lisp code (as `abs' is already a function in Common Lisp!)
  ;; :int = return-value
#+END_SRC

** TODO How can we create bindings for a function when all we did is load the binary shared object?
   The binary *.so file indeed contains all the metadata necessary to refer to by the
   functions name to the machinecode therein!

   TODO:
   The command line tool =nm= lets us see the symbols of an object file, the output of,
   for example =nm libtest.so= returns among other:
   #+BEGIN_SRC shell
                         w _Jv_RegisterClasses
         00000000000006e5 T main
                          U printf@@GLIBC_2.2.5
         0000000000000630 t register_tm_clones
         0000000000000711 T returnsTwo

   #+END_SRC

   There might be some useful info in there pertaining address offset of particular
   functions. (And where to find functions of interest in the process' memory via ptrace!)
 
   For example "T" in the 2nd column means that the particular symbol is in the text/code section

** Pointer and Memory allocation

*** Allocating Memory "Lisp dynamically" and "C dynamically"
   =with-foreign-object= is sometimes called cynamic allocation in Lisp,
   because the object created (allocated) therin only has dynamic extent. Dynamic extent
   in Lisp means that the object lives only in the extend of the (with-foreign-object
   <body>) body. Much like the =let= bindings of special veriables

   =foreign-alloc= on the other hand is _what C calles "dynamic" allocation_. The object
   get allocated to the heap and stay there unless freed by =foreign-free= !!
   In C these kind of objects are created with =malloc()= and firends.

*** Accessing Foreign Memory
    We should always keep in mind that C imposes the semantic on all data that it is
    really just all arrays. Pointers are represented as arrays as well.

    In Lisp we will derefernence pointers with =mem-aref= and =mem-ref= !! Just like
    =AREF= those are SETFable places!!

    "To decide which one to use, consider whether you would use the array index operator
    [n] or the pointer dereference * in C; use mem-aref for array indexing and mem-ref
    for pointer dereferencing."

*** pass by reference
    C code:
    #+BEGIN_SRC C
      int x = 77;
      printf("%d\n", x); // => 77
      passByReference(&x); // sets x = 2
      printf("%d\n", x); // => 2
    #+END_SRC

    Common Lisp translation (but with just Lisp's dynamic allocation):
    #+BEGIN_SRC common-lisp
      (with-foreign-pointer (x-ptr 4)	    ;; 4 = size of int
        (setf (mem-ref x-ptr :int) 77)	    ;; x = 77
        (print (mem-ref x-ptr :int))
        (passbyreference x-ptr)
        (print (mem-ref x-ptr :int)))
    #+END_SRC

** temporary root priviledge for ptrace
   Now because ptrace() is a system call it requires root privilege. To successfully call
   it in lisp requires for lisp to be run as root. There is no other way, _you need to_
   _start the lisp program with root privilege._
   For securities sake it you can _use another system call_ to _turn off root privilege at_
   _runtime_ and turn it back on again. *This only works when the process was started as
   root to begin with!!

   The systemcall to toggle root priviledge is, =seteuid()=

   #+BEGIN_SRC common-lisp
     ;; This only works if you run the lisp program as root to begin with!
     ;; turn on root priviledge
     (sb-posix:seteuid 0)
     ;; do your thang
     (ptrace-or-another-root-priviledged-call)
     ;; become root again
     (sb-posix:seteuid 1000)
   #+END_SRC

   
