# Notes while reading http://tldp.org/LDP/LGNET/81/sandeep.html
#                     http://www.linuxjournal.com/article/6210

* =ptrace()= protoype:
  #+BEGIN_SRC c
    #include <sys/ptrace.h>
    long  int ptrace(enum __ptrace_request request, pid_t pid,
                     void * addr, void * data)
  #+END_SRC

  *request* decides what to be done
  *Pid* - Pid of the _traced_ process
  *Addr* offset in the _user space_
  *data* will be written to, if instructed to do so (depending on request)

* =fork()= =PTRACE_TRACEME=
  This is what we're using: A parent fork()'s and the resulting child calls
  =ptrace(PTRACE_TRACEME, ..)= to initiate being traced by the parent.

* How does =ptrace()= work
  whenever ptrace is called it _first locks the kernel_ (TODO: why), just before
  returning it unlocks the kernel. Depending on the request different things happen
  in between the locks. What follows is an overview of the requests behaviour

** =PTRACE_TRACEME=
   Any signals (except SIGKILL) either delived from outside or from *exec* calls made by
   the process, causes it to stop and lets the parent decide how to proceed.
   This request only sets a flag that grants permission to trace the process.
   *Important insight*: _All the parameters other than *request* are ignored_!

** =PTRACE_ATTACH=
   This is pretty handy, you can make the current process the tracer of the target
   process, "become the parent of that process by attach yourself to it". But =getpid()=
   will return the child's real parent!
   - Note: the *init* process is a big deal - nobody is allowed to trace or control it!  A
     process is also not allowed to trace itself.
   What actually happens:
   1. In the background all the cases are handled (1) is it the init (2) current (3)
      already traced process, before permission to attach is granted.
   2. "the child is removed from the task queue and its parent process field is changed
      (...). It is put to the queue again in such a position that *init* comes next to it"
   3. (!)Interesting: _finally a =SIGSTOP= signal is delivered to it._ This could be useful
      to attach to the process in the moment when inspecting the process memory is of
      interest!

** =PTRACE_DETACH=
   The inverse of =Ptrace_Attach=: (1) reset the Ptrace flag, (2) move child to original
   position of the task queue (note task=process in kernel lingo) and finally (3) the pid
   of the real parent is written in the parent field. "The single-step bit which might
   have been set is reset".
   *addr* is ignored
   *data* arg the parent can send an exit code for the child
   

   
** =PTRACE_CONT=
   to continue child execution

** =PTRACE_SYSCALL=
   will also continue execution of the child, but will stop every syscall invokation the
   child issues. This can be used to implement "strace".

** =PTRACE_SINGLESTEP=
   like =PTRACE_SYSCALL= except we stop here on every instruction!
   
** =PTRACE_GETREGS=
   fetches registers of the process such as: general purpose, floating point.
   *data* will store these, furthermore it expects a =struct user_regs_struct= variable!


* A process issues a system calls
  When a process wants to invoke a system call, it puts the arguments to system calls in
  registers =rdi rsi rdx rcx r8 r9= -in that order- and calls the soft interrupt[fn:1] 0x80 (TODO:
  0x80 on i386). This code is put in the =rax=[fn:2] register on x86_64 architecture machines.
* system call numbers
  Can be found in /usr/include/asm-generic/unistd.h !




* The Process

** contains
   - program counter
   - all the CPU's registers
   - process stack (containing temporary data) such as:
     - routine parameters
     - return addresses
     - saved variables

* Footnotes

[fn:1] a soft interrupt is to be contrasted by a hardware interrupt. Both are like a
function that takes highest priority and interrupts every other non-interrupt execution of
instruction. A hardware interrupt is issued by hardware, a soft interrupt is issued by the
program code.
Examples - hardware interrupt:
1. telling the CPU when I/O components are available - instead of a spin lock solution
2. watchdog circuits - tell the CPU if some hardware component is not working properly
   these are interrupts are highly critical. Interupts have a priority hierarchy scheme so
   that these kind of interrupts can handled before others.
Examples - software interrupt:
1. system calls!
2. Exception system is handled through software interrupts! Such as division-by-zero 

[fn:2] on i386 this is the =eax= register - a 32bit register

  
